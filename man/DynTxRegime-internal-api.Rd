% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/A_generics.R, R/A_List.R,
%   R/A_DecisionPointList.R, R/A_ModelObjSubset.R, R/A_SubsetList.R,
%   R/A_ModelObj_SubsetList.R, R/A_ModelObj_DecisionPointList.R,
%   R/B_TxInfoBasic.R, R/B_TxSubset.R, R/B_TxInfoList.R, R/D_OutcomeNoFit.R,
%   R/E_class_QLearn.R, R/E_class_IQLearnSS.R, R/E_class_IQLearnFS_C.R,
%   R/E_class_IQLearnFS_ME.R, R/E_class_IQLearnFS_VHet.R, R/G_Regime.R,
%   R/H_class_OptimalSeq.R, R/J_class_OptimalClass.R, R/K_Kernel.R,
%   R/L_Surrogate.R, R/M_MethodObject.R, R/N_CVBasic.R, R/N_CVInfo.R,
%   R/P_class_OWL.R, R/Q_class_RWL.R, R/R_class_BOWL.R, R/S_class_EARL.R
\docType{methods}
\name{DynTxRegime-internal-api}
\alias{DynTxRegime-internal-api}
\alias{tmp}
\alias{initialize,List-method}
\alias{[[<-,List-method}
\alias{[[<-,DecisionPointList-method}
\alias{.getDecisionPoint}
\alias{.getSubset}
\alias{initialize,SubsetList-method}
\alias{[[<-,SubsetList-method}
\alias{plot,ModelObj_SubsetList,ANY-method}
\alias{plot,ModelObj_DecisionPointList,ANY-method}
\alias{.compareTx}
\alias{.convertFromBinary}
\alias{.convertToBinary}
\alias{.convertTx}
\alias{.getLevels}
\alias{.getSuperset}
\alias{.getTxName}
\alias{.validTx}
\alias{.getPtsSubset}
\alias{.getSingleton}
\alias{.getSubsetRule}
\alias{.getSubsets}
\alias{.getSubsetRule,ANY-method}
\alias{.identifySubsets}
\alias{.identifySubsets,list,data.frame-method}
\alias{.identifySubsets,list,list-method}
\alias{.identifySubsets,ANY,data.frame-method}
\alias{.identifySubsets,ANY,list-method}
\alias{.identifySubsets,ANY,ANY-method}
\alias{initialize,TxInfoList-method}
\alias{.predictAll}
\alias{Call,QLearn-method}
\alias{coef,QLearn-method}
\alias{DTRstep,QLearn-method}
\alias{estimator,QLearn-method}
\alias{fitObject,QLearn-method}
\alias{optTx,QLearn,data.frame-method}
\alias{optTx,QLearn,missing-method}
\alias{outcome,QLearn-method}
\alias{plot,QLearn,missing-method}
\alias{print,QLearn-method}
\alias{show,QLearn-method}
\alias{summary,QLearn-method}
\alias{DTRstep,IQLearnSS-method}
\alias{DTRstep,IQLearnFS_C-method}
\alias{DTRstep,IQLearnFS_ME-method}
\alias{DTRstep,IQLearnFS_VHet-method}
\alias{.getNumPars}
\alias{.getParNames}
\alias{.getPars}
\alias{.getRegimeFunction}
\alias{.predictOptimalTx}
\alias{.setPars}
\alias{Call,OptimalSeq-method}
\alias{coef,OptimalSeq-method}
\alias{DTRstep,OptimalSeq-method}
\alias{estimator,OptimalSeq-method}
\alias{fitObject,OptimalSeq-method}
\alias{optTx,OptimalSeq,data.frame-method}
\alias{optTx,OptimalSeq,missing-method}
\alias{outcome,OptimalSeq-method}
\alias{plot,OptimalSeq,missing-method}
\alias{propen,OptimalSeq-method}
\alias{regimeCoef,OptimalSeq-method}
\alias{summary,OptimalSeq-method}
\alias{Call,OptimalClass-method}
\alias{coef,OptimalClass-method}
\alias{DTRstep,OptimalClass-method}
\alias{estimator,OptimalClass-method}
\alias{fitObject,OptimalClass-method}
\alias{optTx,OptimalClass,data.frame-method}
\alias{optTx,OptimalClass,missing-method}
\alias{outcome,OptimalClass-method}
\alias{plot,OptimalClass,missing-method}
\alias{propen,OptimalClass-method}
\alias{summary,OptimalClass-method}
\alias{initialize,Kernel-method}
\alias{.getKernelX}
\alias{.kernel}
\alias{.kernelNumPars}
\alias{.dPhiFunc}
\alias{.optim}
\alias{.phiFunc}
\alias{.dobjFn}
\alias{.objFn}
\alias{.subsetObject}
\alias{.valueFunc}
\alias{.optimFunc}
\alias{initialize,CVBasic-method}
\alias{.getValue}
\alias{.getOptimal}
\alias{Call,OWL-method}
\alias{coef,OWL-method}
\alias{cvInfo,OWL-method}
\alias{DTRstep,OWL-method}
\alias{estimator,OWL-method}
\alias{fitObject,OWL-method}
\alias{optimObj,OWL-method}
\alias{optTx,OWL,data.frame-method}
\alias{optTx,OWL,missing-method}
\alias{outcome,OWL-method}
\alias{plot,OWL,missing-method}
\alias{propen,OWL-method}
\alias{regimeCoef,OWL-method}
\alias{summary,OWL-method}
\alias{Call,RWL-method}
\alias{coef,RWL-method}
\alias{cvInfo,RWL-method}
\alias{DTRstep,RWL-method}
\alias{estimator,RWL-method}
\alias{fitObject,RWL-method}
\alias{optimObj,RWL-method}
\alias{optTx,RWL,data.frame-method}
\alias{optTx,RWL,missing-method}
\alias{outcome,RWL-method}
\alias{plot,RWL,missing-method}
\alias{propen,RWL-method}
\alias{regimeCoef,RWL-method}
\alias{residuals,RWL-method}
\alias{summary,RWL-method}
\alias{.newBOWL}
\alias{Call,BOWL-method}
\alias{cvInfo,BOWL-method}
\alias{coef,BOWL-method}
\alias{DTRstep,BOWL-method}
\alias{estimator,BOWL-method}
\alias{fitObject,BOWL-method}
\alias{optimObj,BOWL-method}
\alias{optTx,BOWL,data.frame-method}
\alias{optTx,BOWL,missing-method}
\alias{outcome,BOWL-method}
\alias{plot,BOWL,missing-method}
\alias{propen,BOWL-method}
\alias{regimeCoef,BOWL-method}
\alias{summary,BOWL-method}
\alias{Call,EARL-method}
\alias{coef,EARL-method}
\alias{cvInfo,EARL-method}
\alias{DTRstep,EARL-method}
\alias{estimator,EARL-method}
\alias{fitObject,EARL-method}
\alias{optimObj,EARL-method}
\alias{optTx,EARL,data.frame-method}
\alias{optTx,EARL,missing-method}
\alias{outcome,EARL-method}
\alias{plot,EARL,missing-method}
\alias{propen,EARL-method}
\alias{regimeCoef,EARL-method}
\alias{summary,EARL-method}
\title{Hidden methods}
\usage{
tmp(x)

\S4method{initialize}{List}(.Object, ...)

\S4method{[[}{List}(x, i) <- value

\S4method{[[}{DecisionPointList}(x, i) <- value

.getDecisionPoint(object)

.getSubset(object)

\S4method{initialize}{SubsetList}(.Object, ...)

\S4method{[[}{SubsetList}(x, i) <- value

\S4method{plot}{ModelObj_SubsetList,ANY}(x, y, ...)

\S4method{plot}{ModelObj_DecisionPointList,ANY}(x, y, ...)

.compareTx(object, vec1, vec2)

.convertFromBinary(txObj, ...)

.convertToBinary(txObj, ...)

.convertTx(object, txVec)

.getLevels(object, txVec)

.getSuperset(object)

.getTxName(object)

.validTx(object, txVec)

.getPtsSubset(object)

.getSingleton(object)

.getSubsetRule(object)

.getSubsets(object)

\S4method{.getSubsetRule}{ANY}(object)

.identifySubsets(fSetResult, input, ...)

\S4method{.identifySubsets}{list,data.frame}(fSetResult, input, fSet)

\S4method{.identifySubsets}{list,list}(fSetResult, input, fSet)

\S4method{.identifySubsets}{ANY,data.frame}(fSetResult, input, fSet)

\S4method{.identifySubsets}{ANY,list}(fSetResult, input, fSet)

\S4method{.identifySubsets}{ANY,ANY}(fSetResult, input, fSet)

\S4method{initialize}{TxInfoList}(.Object, ...)

.predictAll(object, newdata, ...)

\S4method{Call}{QLearn}(name, ...)

\S4method{coef}{QLearn}(object, ...)

\S4method{DTRstep}{QLearn}(object)

\S4method{estimator}{QLearn}(x, ...)

\S4method{fitObject}{QLearn}(object, ...)

\S4method{optTx}{QLearn,data.frame}(x, newdata, ...)

\S4method{optTx}{QLearn,missing}(x, newdata, ...)

\S4method{outcome}{QLearn}(object, ...)

\S4method{plot}{QLearn,missing}(x, y, suppress = FALSE, ...)

\S4method{print}{QLearn}(x, ...)

\S4method{show}{QLearn}(object)

\S4method{summary}{QLearn}(object, ...)

\S4method{DTRstep}{IQLearnSS}(object)

\S4method{DTRstep}{IQLearnFS_C}(object)

\S4method{DTRstep}{IQLearnFS_ME}(object)

\S4method{DTRstep}{IQLearnFS_VHet}(object)

.getNumPars(object)

.getParNames(object)

.getPars(object)

.getRegimeFunction(object)

.predictOptimalTx(x, newdata, ...)

.setPars(object, pars)

\S4method{Call}{OptimalSeq}(name, ...)

\S4method{coef}{OptimalSeq}(object, ...)

\S4method{DTRstep}{OptimalSeq}(object)

\S4method{estimator}{OptimalSeq}(x, ...)

\S4method{fitObject}{OptimalSeq}(object, ...)

\S4method{optTx}{OptimalSeq,data.frame}(x, newdata, ...)

\S4method{optTx}{OptimalSeq,missing}(x, newdata, ...)

\S4method{outcome}{OptimalSeq}(object, ...)

\S4method{plot}{OptimalSeq,missing}(x, y, suppress = FALSE, ...)

\S4method{propen}{OptimalSeq}(object, ...)

\S4method{regimeCoef}{OptimalSeq}(object, ...)

\S4method{summary}{OptimalSeq}(object, ...)

\S4method{Call}{OptimalClass}(name, ...)

\S4method{coef}{OptimalClass}(object, ...)

\S4method{DTRstep}{OptimalClass}(object)

\S4method{estimator}{OptimalClass}(x, ...)

\S4method{fitObject}{OptimalClass}(object, ...)

\S4method{optTx}{OptimalClass,data.frame}(x, newdata, ...)

\S4method{optTx}{OptimalClass,missing}(x, newdata, ...)

\S4method{outcome}{OptimalClass}(object, ...)

\S4method{plot}{OptimalClass,missing}(x, suppress = FALSE, ...)

\S4method{propen}{OptimalClass}(object, ...)

\S4method{summary}{OptimalClass}(object, ...)

\S4method{initialize}{Kernel}(.Object, data, model, kparam, ...)

.getKernelX(data, object, ...)

.kernel(object, x1, x2, ...)

.kernelNumPars(object, ...)

.dPhiFunc(surrogate, ...)

.optim(surrogate, ...)

.phiFunc(surrogate, ...)

.dobjFn(par, methodObject, kernel, ...)

.objFn(par, methodObject, kernel, ...)

.subsetObject(methodObject, ...)

.valueFunc(methodObject, ...)

.optimFunc(methodObject, ...)

\S4method{initialize}{CVBasic}(.Object, cvFolds, txVec, ...)

.getValue(object)

.getOptimal(object)

\S4method{Call}{OWL}(name, ...)

\S4method{coef}{OWL}(object, ...)

\S4method{cvInfo}{OWL}(object, ...)

\S4method{DTRstep}{OWL}(object)

\S4method{estimator}{OWL}(x, ...)

\S4method{fitObject}{OWL}(object, ...)

\S4method{optimObj}{OWL}(object, ...)

\S4method{optTx}{OWL,data.frame}(x, newdata, ...)

\S4method{optTx}{OWL,missing}(x, newdata, ...)

\S4method{outcome}{OWL}(object, ...)

\S4method{plot}{OWL,missing}(x, y, suppress = FALSE, ...)

\S4method{propen}{OWL}(object, ...)

\S4method{regimeCoef}{OWL}(object, ...)

\S4method{summary}{OWL}(object, ...)

\S4method{Call}{RWL}(name, ...)

\S4method{coef}{RWL}(object, ...)

\S4method{cvInfo}{RWL}(object, ...)

\S4method{DTRstep}{RWL}(object)

\S4method{estimator}{RWL}(x, ...)

\S4method{fitObject}{RWL}(object, ...)

\S4method{optimObj}{RWL}(object, ...)

\S4method{optTx}{RWL,data.frame}(x, newdata, ...)

\S4method{optTx}{RWL,missing}(x, newdata, ...)

\S4method{outcome}{RWL}(object, ...)

\S4method{plot}{RWL,missing}(x, y, suppress = FALSE, ...)

\S4method{propen}{RWL}(object, ...)

\S4method{regimeCoef}{RWL}(object, ...)

\S4method{residuals}{RWL}(object, ...)

\S4method{summary}{RWL}(object, ...)

.newBOWL(BOWLObj, ...)

\S4method{Call}{BOWL}(name, ...)

\S4method{cvInfo}{BOWL}(object, ...)

\S4method{coef}{BOWL}(object, ...)

\S4method{DTRstep}{BOWL}(object)

\S4method{estimator}{BOWL}(x, ...)

\S4method{fitObject}{BOWL}(object, ...)

\S4method{optimObj}{BOWL}(object, ...)

\S4method{optTx}{BOWL,data.frame}(x, newdata, ...)

\S4method{optTx}{BOWL,missing}(x, newdata, ...)

\S4method{outcome}{BOWL}(object, ...)

\S4method{plot}{BOWL,missing}(x, y, suppress = FALSE, ...)

\S4method{propen}{BOWL}(object, ...)

\S4method{regimeCoef}{BOWL}(object, ...)

\S4method{summary}{BOWL}(object, ...)

\S4method{Call}{EARL}(name, ...)

\S4method{coef}{EARL}(object, ...)

\S4method{cvInfo}{EARL}(object, ...)

\S4method{DTRstep}{EARL}(object)

\S4method{estimator}{EARL}(x, ...)

\S4method{fitObject}{EARL}(object, ...)

\S4method{optimObj}{EARL}(object, ...)

\S4method{optTx}{EARL,data.frame}(x, newdata, ...)

\S4method{optTx}{EARL,missing}(x, newdata, ...)

\S4method{outcome}{EARL}(object, ...)

\S4method{plot}{EARL,missing}(x, y, suppress = FALSE, ...)

\S4method{propen}{EARL}(object, ...)

\S4method{regimeCoef}{EARL}(object, ...)

\S4method{summary}{EARL}(object, ...)
}
\description{
Hidden methods

Retrieve the Decision Point to which modelObj Pertains

Retrieve the Subset to which modelObj Pertains

Constructor method of SubsetList Class

Compare Equivalence of Provided Treatment Vectors

Convert a -1/1 Tx to User Provided Tx

Convert a User Provided Tx Variable to Binary -1/1

Convert Provided Treatment Vector to Appropriate Class

Get Treatment Levels

Retrieve Superset

Retrieve Treatment Variable Name

Ensure Validity of Provided Treatment Vector

Make Predictions for all Treatments.

Uses .predictAll() defined for OutcomeObj objects

Uses optTx defined for DynTxRegime objects

Print Q-Learning Information

Show Q-Learning Information
}
\keyword{internal}
